<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>创建对象</title>
</head>
<body>
<script>
//创建一个Object实例
var person = new Object();
person.name = 'peter';
person.age = 24;
person.job = 'software engineer';

person.sayName = function(){
    alert(this.name);
}

//用对象字面量的方式创建对象
var person2 = {
    name:'tom',
    age:25,
    job:'software engineer',
    sayName:function(){
        alert(this.name);
    }
}

//工厂模式
function createPerson(name,age,job){
    var obj = new Object();
    obj.name = name;
    obj.age = age;
    obj.job = job;
    obj.sayName = function(){
        alert(this.name);
    }
    return obj;
}

var person1 = createPerson('peter',24,'software engineer');
var person2 = createPerson('tom',25,'doctor');

//构造函数的方式
function Person(name,age,job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function(){
        alert(this.name);
    }
}

var person1 = new Person('peter',24,'software engineer');
var person2 = new Person('tom',25,'doctor');
alert(person1.sayName == person2.sayName);

function Person(name,age,job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = sayName;
}

function sayName(){
    alert(this.name);
}

alert(person1.constructor == Person);
alert(person2.constructor == Person);

alert(person1 instanceof Object);
alert(person1 instanceof Person);

/*
工厂方式和面向对象的不同之处
1/没有显示的创建对象
2/直接将属性和方法赋给了this对象
3/没有return语句
*/

//当作构造函数使用
var person = new Person('peter',28,'software engineer');
person.sayName();

//作为普通函数调用
Person('tom',25,'doctor');  //添加到window
window.sayName();

//在另一个对象中的作用域中调用
var o = new Object();
Person.call(o,'smith',24,'student');
o.sayName();

var obj = new Object();
Person.apply(obj,['rose',22,'teacher']);
obj.sayName();

//原型模式
function Person(){
}

Person.prototype.name = 'peter';
Person.prototype.age = 25;
Person.prototype.job = 'software engineer';
Person.prototype.sayName = function(){
    alert(this.name);
}

var person1 = new Person();
var person2 = new Person();
person1.name = 'tom';
alert(person1.name);
alert(person2.name);
person1.sayName();

alert(Person.prototype.isPrototypeOf(person1));
alert(Object.getPrototypeOf(person1) == Person.prototype); //获取对象的原型


function Person(){

}

Person.prototype.name = 'peter';
Person.prototype.age = 18;
Person.prototype.job = 'software engineer';
Person.prototype.sayName = function(){
    alert(this.name);
}

Person.prototype = {
    name:'peter',
    age:21,
    job:'software engineer',
    sayName:function(){
        alert(this.name);
    }
}


//获取对象上所有可枚举的实例属性
var keys = Object.keys(Person.prototype);
// alert(keys);

var p1 = new Person();
p1.name = 'tom';
p1.age = 20;
var p1keys = Object.keys(p1);
alert(p1keys);

//判断某个属性是否属于原型对象
function hasPrototypeProperty(object,attr){
    return !object.hasOwnProperty(attr) && (attr in object);
}

var person = new Person();
alert(hasPrototypeProperty(person,'name'));
person.name = 'tom';
alert(hasPrototypeProperty(person,'name'));
//03.18注释
</script>
</body>
</html>
